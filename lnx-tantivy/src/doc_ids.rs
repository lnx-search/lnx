use anyhow::Result;
use datacake::rpc::DataView;
use lnx_tools::binary_fuse::{Fuse16, Fuse16Builder};
use rkyv::AlignedVec;
use tantivy::SegmentId;

#[derive(Default)]
/// A binary fuse filter for document IDs.
pub struct DocIdFuseFilterBuilder {
    inner: Fuse16Builder,
}

impl DocIdFuseFilterBuilder {
    #[inline]
    /// Inserts a new key into the fuse filter.
    ///
    /// This assumes the key is generated by city hash.
    pub fn insert(&mut self, key: u64) -> bool {
        self.inner.insert_digest(key)
    }

    /// Serializes the builder.
    pub fn build_bytes(self) -> Result<AlignedVec> {
        let filter = self.inner.build()?;
        let serialized = datacake::rpc::to_view_bytes(&filter)?;
        Ok(serialized)
    }
}

/// A wrapper around a archived fuse filter.
pub struct DocIdFuseFilter {
    /// The segment the filter belongs to.
    segment_id: SegmentId,
    /// The view of the fuse filter.
    inner: DataView<Fuse16>,
}

impl DocIdFuseFilter {
    #[inline]
    /// The segment ID the filter belongs to.
    pub fn segment_id(&self) -> SegmentId {
        self.segment_id
    }

    #[inline]
    /// Returns if the key definitely does not exist in the filter
    /// or if it *probably* exists in the filter.
    pub fn contains_key(&self, key: u64) -> bool {
        self.inner.contains_digest(key)
    }

    #[inline]
    /// Creates a new fuse filter from the serialized bytes and segment ID.
    pub fn from_bytes(segment_id: SegmentId, buffer: AlignedVec) -> Result<Self> {
        let inner = DataView::using(buffer)?;
        Ok(Self { segment_id, inner })
    }
}
