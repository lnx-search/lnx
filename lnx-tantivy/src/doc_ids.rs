use std::hash::{BuildHasher, Hash, Hasher};
use std::sync::Arc;

use ahash::HashMap;
use anyhow::Result;
use arc_swap::ArcSwap;
use datacake::rpc::DataView;
use parking_lot::Mutex;
use lnx_tools::binary_fuse::{Fuse16, Fuse16Builder};
use rkyv::AlignedVec;
use slab::Slab;
use tantivy::SegmentId;


type FilterSet = ArcSwap<Slab<DocIdFuseFilter>>;
const FILTER_SHARDS: usize = 12;

#[derive(Clone, Default)]
/// A structure that maintains the fuse filters
/// for each segment in order to check if a document ID exists.
pub struct SegmentDocIds {
    /// The random hasher state.
    random_state: ahash::RandomState,
    /// The currently active segment filters.
    ///
    /// This is split into multiple shards to avoid heavy lock contention at
    /// higher ingestion throughput.
    segments: Arc<[SegmentShard; FILTER_SHARDS]>,
}

impl SegmentDocIds {
    fn get_segment_shard(&self, segment_id: SegmentId) -> &SegmentShard {
        let key = {
            let mut hasher = self.random_state.build_hasher();
            segment_id.hash(&mut hasher);
            hasher.finish()
        };

        let shard_id = (key % FILTER_SHARDS as u64) as usize;
        &self.segments[shard_id]
    }

    /// Adds a new segment filter.
    ///
    /// If the segment already exists this will be ignored.
    ///
    /// The method returns if the filter was inserted or not.
    pub fn add_segment_filter(&self, filter: DocIdFuseFilter) -> bool {
        let segment_id = filter.segment_id();
        let shard = self.get_segment_shard(segment_id);

        let mut lock = shard.segment_id_mapper.lock();
        if lock.contains_key(&segment_id) {
            return false;
        }

        let mut last_id = 0;
        shard.segments.rcu(|inner| {
            let mut segments = (**inner).clone();
            last_id = segments.insert(filter.clone());
            segments
        });

        lock.insert(segment_id, last_id);

        true
    }

    /// Removes a segment filter if it exists.
    pub fn remove_segment_filter(&self, segment_id: SegmentId) {
        let shard = self.get_segment_shard(segment_id);

        let mut lock = shard.segment_id_mapper.lock();
        let pos = { lock.remove(&segment_id) };

        if let Some(pos) = pos {
            shard.segments.rcu(|inner| {
                let mut segments = (**inner).clone();
                segments.remove(pos);
                segments
            });
        }
    }
}

#[derive(Default)]
struct SegmentShard {
    /// A mapping of segment ID to index in the segments list.
    segment_id_mapper: Mutex<HashMap<SegmentId, usize>>,
    /// The currently active segment filters.
    segments: FilterSet,
}

#[derive(Default)]
/// A binary fuse filter for document IDs.
pub struct DocIdFuseFilterBuilder {
    inner: Fuse16Builder,
}

impl DocIdFuseFilterBuilder {
    #[inline]
    /// Inserts a new key into the fuse filter.
    ///
    /// This assumes the key is generated by city hash.
    pub fn insert(&mut self, key: u64) -> bool {
        self.inner.insert_digest(key)
    }

    /// Serializes the builder.
    pub fn build_bytes(self) -> Result<AlignedVec> {
        let filter = self.inner.build()?;
        let serialized = datacake::rpc::to_view_bytes(&filter)?;
        Ok(serialized)
    }
}

#[derive(Clone)]
/// A wrapper around a archived fuse filter.
pub struct DocIdFuseFilter {
    /// The segment the filter belongs to.
    segment_id: SegmentId,
    /// The view of the fuse filter.
    inner: DataView<Fuse16>,
}

impl DocIdFuseFilter {
    #[inline]
    /// The segment ID the filter belongs to.
    pub fn segment_id(&self) -> SegmentId {
        self.segment_id
    }

    #[inline]
    /// Returns if the key definitely does not exist in the filter
    /// or if it *probably* exists in the filter.
    pub fn contains_key(&self, key: u64) -> bool {
        self.inner.contains_digest(key)
    }

    #[inline]
    /// Creates a new fuse filter from the serialized bytes and segment ID.
    pub fn from_bytes(segment_id: SegmentId, buffer: AlignedVec) -> Result<Self> {
        let inner = DataView::using(buffer)?;
        Ok(Self { segment_id, inner })
    }
}
